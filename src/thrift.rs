// autogenerated by thrust
#![allow(dead_code, unused_imports)]
use thrust::protocol::{Error, ThriftType};
use thrust::{ThrustResult, ThrustError};
use std::io;
use std::thread::JoinHandle;
use std::net::SocketAddr;
use std::str::FromStr;
use std::sync::mpsc::{Sender, Receiver};
use std::collections::{HashMap, HashSet};
use thrust::transport::*;
use thrust::protocol::{ThriftDeserializer, ThriftSerializer, ThriftMessageType};
use thrust::protocol::{Serializer, Deserializer};
use thrust::protocol::{Deserialize, Serialize, ThriftMessage};
use thrust::binary_protocol::BinaryProtocol;
use futures::{Poll, Async, Future};
use tokio_core::easy::{Parse, EasyBuf};
use thrust_tokio::framed_transport::*;

pub trait FlockService: Send {
    fn isLoggedIn(&self, token: String) -> Box<Future<Item = bool, Error = io::Error>>;
    fn isLoggedOut(&self, token: String) -> Box<Future<Item = bool, Error = io::Error>>;
}

#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord)]
pub enum FlockServiceMethods {
    MisLoggedIn,
    MisLoggedOut,
}


impl FromStr for FlockServiceMethods {
    type Err = io::Error;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        use self::FlockServiceMethods::*;
        match s {
            "isLoggedIn" => Ok(MisLoggedIn),
            "isLoggedOut" => Ok(MisLoggedOut),
            _ => Err(io::Error::new(io::ErrorKind::InvalidData, "failed to parse thrift data"))
        }
    }
}

impl ParseThrift for FlockServiceMethods {
    type Args = FlockServiceMethodArgs;
    type Ret = FlockServiceMethodReturn;
    fn parse_args<D: Deserializer + ThriftDeserializer>(&self, proto: &mut D) -> Result<Self::Args, Error> {
        use self::FlockServiceMethodArgs::*;
        use self::FlockServiceMethods::*;
        match self {
            &MisLoggedIn => Flock_isLoggedIn_Args::deserialize(proto).map(AisLoggedIn),
            &MisLoggedOut => Flock_isLoggedOut_Args::deserialize(proto).map(AisLoggedOut),
        }
    }

    fn parse_ret<D: Deserializer + ThriftDeserializer>(&self, proto: &mut D) -> Result<Self::Ret, Error> {
        use self::FlockServiceMethodReturn::*;
        use self::FlockServiceMethods::*;
        match self {
            &MisLoggedIn => bool::deserialize(proto).map(RisLoggedIn),
            &MisLoggedOut => bool::deserialize(proto).map(RisLoggedOut),
        }
    }
}


#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord)]
pub enum FlockServiceMethodArgs {
    AisLoggedIn(Flock_isLoggedIn_Args),
    AisLoggedOut(Flock_isLoggedOut_Args),
}

impl Serialize for FlockServiceMethodArgs {
    fn serialize<S>(&self, s: &mut S) -> Result<(), Error>
        where S: Serializer + ThriftSerializer
    {
        use self::FlockServiceMethodArgs::*;
        match self {
            &AisLoggedIn(ref b) => {
                try!(s.write_message_begin("isLoggedIn", ThriftMessageType::Call));
                try!(b.serialize(s));
                try!(s.write_message_end());
            },
            &AisLoggedOut(ref b) => {
                try!(s.write_message_begin("isLoggedOut", ThriftMessageType::Call));
                try!(b.serialize(s));
                try!(s.write_message_end());
            },
        };
        Ok(())
    }
}


#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord)]
pub enum FlockServiceMethodReturn {
    RisLoggedIn(bool),
    RisLoggedOut(bool),
}


impl Serialize for FlockServiceMethodReturn {
    fn serialize<S>(&self, s: &mut S) -> Result<(), Error>
        where S: Serializer + ThriftSerializer
    {
        use self::FlockServiceMethodReturn::*;
        match self {
            &RisLoggedIn(ref b) => {
                try!(s.write_message_begin("isLoggedIn", ThriftMessageType::Reply));
                try!(b.serialize(s));
                try!(s.write_message_end());
            },
            &RisLoggedOut(ref b) => {
                try!(s.write_message_begin("isLoggedOut", ThriftMessageType::Reply));
                try!(b.serialize(s));
                try!(s.write_message_end());
            },
        };
        Ok(())
    }
}

#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord)]
pub struct Flock_isLoggedIn_Args {
    pub token: String,
}

#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord)]
pub struct Flock_isLoggedOut_Args {
    pub token: String,
}

impl Serialize for Flock_isLoggedIn_Args {
    fn serialize<S>(&self, s: &mut S) -> Result<(), Error>
        where S: Serializer + ThriftSerializer
    {
        try!(s.write_struct_begin("Flock_isLoggedIn_Args"));
        try!(s.write_field_begin("token", ThriftType::String, 1));
        try!(self.token.serialize(s));
        try!(s.write_field_stop());
        try!(s.write_field_end());
        try!(s.write_struct_end());
        Ok(())
    }
}

impl Serialize for Flock_isLoggedOut_Args {
    fn serialize<S>(&self, s: &mut S) -> Result<(), Error>
        where S: Serializer + ThriftSerializer
    {
        try!(s.write_struct_begin("Flock_isLoggedOut_Args"));
        try!(s.write_field_begin("token", ThriftType::String, 1));
        try!(self.token.serialize(s));
        try!(s.write_field_stop());
        try!(s.write_field_end());
        try!(s.write_struct_end());
        Ok(())
    }
}

impl Deserialize for Flock_isLoggedIn_Args {
    fn deserialize<D>(de: &mut D) -> Result<Self, Error>
        where D: Deserializer + ThriftDeserializer
    {
        try!(de.read_struct_begin());
        let args = Flock_isLoggedIn_Args {
            token: {
                match try!(de.read_field_begin()).ty {
                    ThriftType::Stop => {
                        try!(de.read_field_begin());
                    }
                    _ => {}
                }
                let val = try!(de.deserialize_str());
                try!(de.read_field_begin()); // assert ty == Stop
                try!(de.read_field_end());
                val
            },
        };
        try!(de.read_struct_end());
        Ok(args)
    }
}

impl Deserialize for Flock_isLoggedOut_Args {
    fn deserialize<D>(de: &mut D) -> Result<Self, Error>
        where D: Deserializer + ThriftDeserializer
    {
        try!(de.read_struct_begin());
        let args = Flock_isLoggedOut_Args {
            token: {
                match try!(de.read_field_begin()).ty {
                    ThriftType::Stop => {
                        try!(de.read_field_begin());
                    }
                    _ => {}
                }
                let val = try!(de.deserialize_str());
                try!(de.read_field_begin()); // assert ty == Stop
                try!(de.read_field_end());
                val
            },
        };
        try!(de.read_struct_end());
        Ok(args)
    }
}
