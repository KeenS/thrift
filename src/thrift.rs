// autogenerated by thrust
#![allow(dead_code, unused_imports)]
use thrust::protocol::{Error, ThriftType};
use thrust::{ThrustResult, ThrustError};
use std::io;
use std::thread::JoinHandle;
use std::net::SocketAddr;
use std::sync::mpsc::{Sender, Receiver};
use std::collections::{HashMap, HashSet};
use thrust::protocol::{ThriftDeserializer, ThriftSerializer, ThriftMessageType};
use thrust::protocol::{Serializer, Deserializer};
use thrust::protocol::{Deserialize, Serialize, ThriftMessage};
use thrust::binary_protocol::BinaryProtocol;
use futures::Future;


pub trait FlockService: Send {
    fn isLoggedIn(&mut self, token: String) -> Box<Future<Item = bool, Error = io::Error>>;
}


pub struct Flock_isLoggedIn_Args {
    pub token: String,
}

impl Serialize for Flock_isLoggedIn_Args {
    fn serialize<S>(&self, s: &mut S) -> Result<(), Error>
        where S: Serializer + ThriftSerializer
    {
        try!(s.write_struct_begin("Flock_isLoggedIn_Args"));
        try!(s.write_field_begin("token", ThriftType::String, 1));
        try!(self.token.serialize(s));
        try!(s.write_field_stop());
        try!(s.write_field_end());
        try!(s.write_struct_end());
        Ok(())
    }
}
impl Deserialize for Flock_isLoggedIn_Args {
    fn deserialize<D>(de: &mut D) -> Result<Self, Error>
        where D: Deserializer + ThriftDeserializer
    {
        try!(de.read_struct_begin());
        let args = Flock_isLoggedIn_Args {
            token: {
                match try!(de.read_field_begin()).ty {
                    ThriftType::Stop => {
                        try!(de.read_field_begin());
                    }
                    _ => {}
                }
                let val = try!(de.deserialize_str());
                try!(de.read_field_end());
                val
            },
        };
        try!(de.read_struct_end());
        Ok(args)
    }
}
// impl FlockService for FlockClient {
//     fn isLoggedIn(&mut self, token: String) -> Future<bool> {
//         use std::io::Cursor;
//         let (res, future) =
//             Future::<(ThriftMessage, BinaryDeserializer<Cursor<Vec<u8>>>)>::channel();
//         let mut buf = Vec::new();
//         {
//             let mut se = BinarySerializer::new(&mut buf);
//             se.write_message_begin("isLoggedIn", ThriftMessageType::Call);
//             let args = Flock_isLoggedIn_Args { token: token };
//             args.serialize(&mut se);
//             se.write_message_end();
//         }
//         self.dispatcher.send(Incoming::Call("isLoggedIn".to_string(), buf, Some(res))).unwrap();
//         future.and_then(move |(msg, de)| Async::Ok("foobar".to_string()))
//     }
// }


// pub struct FlockServer {
//     dispatcher: Sender<dispatcher::Incoming>,
//     pub handle: JoinHandle<ThrustResult<()>>,
// }

// impl FlockServer {
//     pub fn new<S>(service: S, addr: SocketAddr) -> FlockServer
//         where S: 'static + FlockService
//     {
//         use std::thread;
//         use std::sync::mpsc::channel;
//         use std::io::Cursor;

//         let (sender, receiver) = channel();
//         let (handle, tx) = Dispatcher::spawn(dispatcher::Role::Server(addr, sender)).unwrap();

//         let send_tx = tx.clone();
//         thread::spawn(move || {
//             let mut runner = FlockRunner::new(service);
//             for (token, buf) in receiver.iter() {
//                 let mut de = BinaryDeserializer::new(Cursor::new(buf));
//                 match de.read_message_begin() {
//                     Ok(msg) => {
//                         match runner.run(&mut de, msg) {
//                             Ok(f) => {
//                                 let chan = send_tx.clone();
//                                 f.and_then(move |buf| {
//                                     chan.send(Incoming::Reply(token, buf));
//                                     Async::Ok(())
//                                 });
//                             }
//                             Err(err) => {}
//                         }
//                     }
//                     Err(err) => {
//                         println!("[server]: error parsing thrift message: {:?}", err);
//                     }
//                 }
//             }
//         });

//         FlockServer {
//             dispatcher: tx,
//             handle: handle,
//         }
//     }
// }
